# 多线程&并发

## 多线程

### 创建线程

- 继承Thread类，重写run()

	- 单继承，无法继承其他类

- 实现Runnable接口，实现接口run()

	- 不能直接捕获run()方法异常，需要使用setDefaultUncaughtExceptionHandler()

- 实现Callable接口，FutureTask类创建方法体

	- 可抛出异常

### 线程生命周期

- New

	- 新建状态

- Runnable

	- 线程已经被启动，正在等待被分配CPU时间片，在JVM中可运行

- Blocked

	- 正在运行的线程让出cpu并暂停执行，直到线程重新进入Runnable状态，结束阻塞
	- 分类

		- 等待阻塞

			- 线程调用wait()

		- 同步阻塞

			- 线程获取synchronized同步锁失败

		- 其他阻塞

			- 线程调用sleep()或join()或发出IO请求

- Running

	- 获取cpu权限执行，只能从Runnable状态进入到运行状态

- Dead

	- 执行结束或异常退出

### 线程分类

- 守护线程

	- 后台线程，为其他线程提供服务
	- 非守护线程全部进入dead状态，jvm会自动退出
	- Thread.setDaemon() 必须在start()前

- 非守护线程

	- 普通线程

### 线程状态改变操作

- Thread.sleep()

	- 当前线程调用，调用后进入Timed_waiting状态
	- 不释放对象锁，休眠结束自动进入Runnable状态

- Thread.yield()

	- 当前线程调用，当前线程 放弃获取的cpu时间片，不释放锁资源，变为Runnable状态，让OS再次选择线程
	- 让相同优先级的线程轮流执行，但并不保证一定会轮流执行——无法保证达到让步目的

- Thread.join()

	- 优先执行join进来的线程，再继续执行当前线程

- Object.wait()

	- 释放对象锁，进入等待池

- Object.notify()/notifyAll()

	- 唤醒wait()线程，选择是任意的或全部唤醒，唤醒后，线程恢复到wait时的状态

- LockSupport.park()

	- 阻塞线程

- LockSupport.unpark()

	- 唤醒线程，相比notify()、notifyAll()能够唤醒某个线程

## 线程池

### Executor

- submit()

	- 有返回值，可捕获异常

- execute()

	- 无返回值，捕捉不到异常

### ExecutorService

- execute()
- submit()
- shutdown()

	- 停止接收新任务，原来的任务继续执行

- shutdownNow()

	- 停止接收新任务，原来的任务停止执行

- awaitTermination()

	- 阻塞当前线程，返回是否线程都执行完成

### ThreadFactory

### ThreadPoolExecutor

- CorePoolSize

	- 核心池大小

- maxNumPoolSize

	- 线程池大小

- KeepAliveTime

	- 保持连接时间

- TimeUnit

	- 时间单元

- BlockingQueue

	- 阻塞式队列

- RejectedExecutionHandler

	- 拒绝任务策略

### 拒绝策略

- ThreadPoolExecutor.AbortPolicy

	- 丢弃任务并抛出异常

- ThreadPoolExecutor.DiscardPolicy

	- 丢弃任务，不抛出异常

- ThreadPoolExecutor.DiscardOldestPolicy

	- 丢弃队列最前面的任务，重新提交被拒绝的任务

- ThreadPoolExecutor.CallerRunsPolicy

	- 由调用线程（提交任务的线程）处理该任务

### 创建线程池

- Executors

	- newCachedThreadPool

		- 可缓存线程池
		- 可灵活创建与回收
		- 可以重复利用

	- newFixedThreadPool

		- 定长线程池，可控制最大并发数，超出线程在队列中等待

	- newSingleThreadEexcutor

		- 单线程化线程池，遵循FIFO/LIFO

	- NewScheduledThreadPool

		- 定长线程池，支持周期性任务执行

- 创建固定线程池

	- 核心数N
	- CPU密集型 ，设置线程池大小为N或N+1
	- IO密集型，设置线程池大小为2N或2N+2

## 多线程安全

### volatile

- 保证修改的值会被立即更新到主存
- 保证可见，不保证原子性

### synchronized

- 保证同步中只有一个线程在运行
- 保证线程安全
- 抢锁消耗资源，效率低
- 同步函数 = this锁
- 静态同步函数 = this.class

### lock

- 手动开启锁，手动释放锁
- 灵活性高
- 非阻塞式获取锁
- 遇到异常就中断锁，synchronized不能

### 不可变

- 不可变的对象一定是线程安全的
- final、String、Enum、Number..
- 对于集合类型，可以使用unmodifiable方法获取不可变集合

### 悲观锁

- 阻塞同步
- 线程阻塞和唤醒带来的性能问题
- synchronized、ReentrantLock

### 乐观锁

- 基于冲突检测
- 先进行操作，若有其他线程争用共享数据，则采取补偿措施（不断重复，直至成功）
- CAS

### 无同步

- 栈封闭

	- 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机中，是线程私有

- 线程本地存储

	- 尽可能在每次使用ThreadLocal后手动调用remove()，以避免出现ThreadLocal经典的内存泄露
	- 看看共享数据的代码能否保证在同一个线程中运行，“一个请求对应一个服务器线程”

- 可重入代码

	- 可以在代码执行的任何时刻中断它，转而去执行另外一段代码包括递归调用本身，控制权返回时，原来的程序不会出现问题
	- 不依赖存储在堆上的数据和公用的系统资源
	- 用到的状态量都由参数传入
	- 不调用非可重入方法等

## 多线程并发

### JUC

- 锁机制类

	- Lock

		- 使用方式灵活可控
		- 性能开销小
		- java.util.concurrent.locks

	- Condition

		- Lock.newCondition()创建
		- 类似于wait/notify

	- ReentrantLock

		- 可中断，可同时绑定多个condition对象

	- ReadWriteLock

		- 管理一组锁，一个读锁一个写锁
		- 读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的
		- 每次只能一个写线程，但是可以有多个读线程
		- 适用于读多写少的情况

	- LockSupport

		- 类似于Thread类的静态写法，专门处理执行代码的本线程

	- 用锁的最佳实践

		- 永远只在更新对象的成员变量时加锁
		- 永远只在访问可变的成员变量时加锁
		- 永远不在调用其他对象的方法时加锁

	- 降低锁范围、细分锁粒度

- 原子操作类

	- AutomicInteger
	- AutomicLong
	- LongAdder

		- 对AutomicLong改进
		- 多路归并

- 线程池相关类

	- Future

		- 异步执行结束后，返回的结果会保存在Future中。
		- 当执行一个长时间运行的任务时，使用future暂时处理其他任务，等场任务执行结束后再返回结果
		- 场景：计算密集场景、处理大数据量、远程方法调用

	- Callable
	- Executor
	- ExecutorService

- 工具类

	- CountDownLatch

		- 阻塞主线程，N个子线程满足条件时主线程继续
		- 维护一个计数器cnt，每次调用countDown()计数器值-1，计数器值为0时，唤醒调用wait()方法而等待的线程

	- CyclicBarrier

		- 用来控制多个线程互相等待，只有多个线程都到达时，线程继续执行
		- CountDownLatch_CyclicBarrier.png

	- Semaphore

		- N=1 ，独占锁
		- 类似操作系统的信号量，可以控制对互斥资源的访问线程数
		- synchronized进化版

- 并发集合类

	- CopyOnWriteArrayList
	- ConcurrentMap

- 缓冲队列

	- 双缓冲队列，允许两个线程同时向队列读写操作，在保证并发安全的同时，提高队列的存储效率
	- ArrayBlockingQueue

		- 需指定大小，FIFO

	- LinkedBlockingQueue

		- 可指定大小，若不指定，由Integer.MAX_VALUE决定，FIFO

	- PriorityBlockingQueue

		- 类似于LinkedBlockingQueue，非FIFO，依据对象的自然顺序或构造函数Comparator决定

	- SynchronizedQueue

		- 特殊的BlockingQueue，操作必须读写交替完成

### 并发压力跟锁性能的关系

- 压力一般情况下，无锁更快，大部分一次写入
- 压力非常大情况下，自旋导致重试过多，资源消耗量大

## Java内存模型

### 并发相关性质

- 原子性

	- 原子操作，要么执行要么不执行

- 有序性

	- 重排序过程会影响到多线程并发问题

- 可见性

	- 当一个线程修改了共享变量的值，其他线程能够立即看到更改
	- java内存模型通过变量修改后，将新值同步回主存

		- volatile
		- synchronized
		- final

### happens-before原则

- 程序次数原则

	- 一个线程内，按照代码先后顺序

- 锁定规则

	- 一个unlock操作先行发生于后main对同一个锁的lock操作

- volatile变量规则

	- 对一个变量的写操作先发生于后面对变量的读操作

- 传递规则

	- 如果操作A先行发生于B操作，而B先行发生于C操作，则A先行于C

- 线程启动规则

	- Thread对象的start()方法先行发生于此线程的其他操作

- 线程中断规则

	- 对线程interrupt()方法的调用先行于发生被中断线程的代码检测到中断事件的发生

- 线程终结规则

	- 线程中所有操作都先行发生于线程的终止检测，可Thread.join()方法结束，Thread.isAlive()的返回值手段检测到线程已是否已经终止执行

- 对象终结规则

	- 一个对象的初始化完成先行发生于他的finalize()方法的开始

## 锁优化

### jvm对synchronized的优化

### 自旋锁

- 互斥同步进入阻塞状态的开销都很大，应该尽量避免
- 获取自旋锁时，若锁已经有持有者，则获取锁的操作将自旋直至锁释放
- 优点：避免进入阻塞状态
- 缺点：执行循环占用cpu时间，只适用于共享数据的锁定状态很短的场景

### 锁消除

- 对于检测出不可能存在竞争的共享数据的锁进行消除
- 通过逃逸分析来支持，若堆上共享数据不可能逃逸出去被其他线程访问到，就可以当做私有数据对待，对他们的锁进行消除

### 锁粗化

- 如果一系列连续操作都对同一个对象反复加锁＆释放锁，就会导致性能损耗
- 虚拟机检测到这种情况，会把锁的范围扩展整个操作序列的外部

### 轻量级锁

- 相对于重量级锁，使用CAS操作避免重量级锁使用互斥量的开销

### 偏向锁

- 偏向于让第一个获取锁对象的线程，该线程在之后获取该说就不需要进行同步操作

*XMind - Trial Version*